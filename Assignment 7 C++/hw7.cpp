/**
*
*Purpose:This program shows how use ifstream, ofstream, and how to create a link list of objects tha hold objects.
*
*Completion Time: 4 Hours
*
*@author: Arnold Shibu, Code provided by Ruben Acuna
*@verison: 9/15/2021
*/

// CSE240 
// Be sure to add the standard header above.
// Write the compiler used: Visual studio 


// READ BEFORE YOU START:
// You are given a partially completed program that creates a list of rooms.
// Each room has name, number of rooms and library type (hayden or noble).
// This information is stored as an object of Room class. Class defined in room.h
// The classes Hayden and Noble are child classes of the Room class.
// When adding a new room, these child classes are used to make the room node of the list.
// So each node in the list is actually an object of either Hayden or Noble class.

//
// To begin, you should trace through the given code and understand how it works.
// Please read the instructions above each required function and follow the directions carefully.
// Do not modify given code.

// You can assume that all input is valid:
// Valid name:	String containing alphabetical letters
// Valid number: a positive integer

#include <iostream>
#include <fstream>
#include <string>
#include "Container.h"
#include "room.h"
#include "noble.h"
#include "hayden.h"

using namespace std;

// functions already implemented:
void executeAction(char c);
Room* searchRoom(string name_input);


// functions that need implementation:
void addRoom(string name_input, int no_input, libraryType type);			// 7 points
void displayList();							// 4 points
void save(string fileName);					// 7 points
void load(string fileName);					// 7 points

Container* list = NULL;				// global list

int main()
{
	char c = 'i';				// initialized to a dummy value

  // During first execution, there will be no list.txt in source directory. list.txt is generated by save() while exiting the program.
	load("list.txt");			
	do {
		cout << "\nCSE240 HW10\n";
		cout << "Please enter your selection:\n";
		cout << "\t a: add a new room\n";
		cout << "\t d: display room list\n";
		cout << "\t c: change library type\n";
		cout << "\t q: quit\n";
		cin >> c;
		cin.ignore();
		executeAction(c);
	} while (c != 'q');

	save("list.txt");

	list = NULL;

	return 0;
}

// Ask for details from user for the given selection and perform that action
// Read the function case by case
void executeAction(char c)
{
	string name_input;
	int no_input;
	int type_input = 2;
	libraryType type;
	Room* roomResult = NULL;

	switch (c)
	{
	case 'a':	// add room
				// input room details from user
		cout << endl << "Enter room name: ";
		getline(cin, name_input);
		cout << "Enter number of rooms: ";
		cin >> no_input;
		cin.ignore();

		while (!(type_input == 0 || type_input == 1))
		{
			cout << "Enter library type: " << endl;
			cout << "0. Hayden " << endl;
			cout << "1. Noble" << endl;
			cin >> type_input;
			cin.ignore();
		}
		type = (libraryType)type_input;

		// searchRoom() will return the room object if found, else returns NULL
		roomResult = searchRoom(name_input);
		if (roomResult == NULL)
		{
			addRoom(name_input, no_input, type);
			cout << endl << "Room added to list!" << endl << endl;
		}
		else
			cout << endl << "Room already present in the list!" << endl << endl;

		break;

	case 'd':		// display the list
		displayList();
		break;

	case 'c':		// change room type
		cout << endl << "Enter room name: ";
		getline(cin, name_input);
		// searchRoom() will return the room node if found, else returns NULL
		roomResult = searchRoom(name_input);
		if (roomResult == NULL)
		{
			cout << endl << "Room not in list!" << endl << endl;
		}
		else
		{
			// if room exists in the list, then ask user for new number of rooms
			cout << endl << "Enter new library type: "<<endl;
                        cout << "0. Hayden " << endl;
                        cout << "1. Noble" << endl;
			cin >> type_input;
			cin.ignore();
			type = (libraryType)type_input;
			// Q3c Call changeLibraryType() here   (1 point)
			// 'roomResult' contains the room whose Library Type is to be changed.
			// Call the function with appropriate arguments.

			//calls change library
			changeLibraryType(roomResult, type);

			cout << endl << "Library type changed!" << endl << endl;
		}
		break;

	case 'q':		// quit
		break;

	default: cout << c << " is invalid input!\n";
	}

}

// No implementation needed here, however it may be helpful to review this function
Room* searchRoom(string name_input)
{

	Container* tempList = list;			// work on a copy of 'list'

	while (tempList != NULL)			// parse till end of list
	{
		if (tempList->room->getName() == name_input)
		{
			return tempList->room;	// return the room if found
		}

		tempList = tempList->next;		// parse the list
	}

	return NULL;						// return NULL if room not found in list
}

// Q3b: Define Friend Function changeLibraryType()  (3 points)
// Define the function changeLibraryType()that is declared in room.h file.
// This function sets the new library type for the room. The room object and new library type (as integer) are to be passed as function arguments.
// Use 'd' display option after using 'c' option to verify.
// You will need to implement add() and displayList() before you test this function.
void changeLibraryType(Room* r, libraryType lib) {
	r->lib = lib;
}


// Q4: addRoom  (7 points)
// This function is used to add a new room to the global linked list 'list'. You may add the new room to head or tail of the list. (Sample solution adds to tail)
// libraryType 'type' can be hayden or noble. You will need to use the function argument ‘type’ to determine which constructor to use to create new room node.
// For example, if the user enters type as 'noble', then you need to use Noble class and constructor to create new room node and add it to the list.
// NOTE: In executeAction(), searchroom() is called before this function. Therefore no need to check here if the room exists in the list.
//       See how this fucntion is called in case 'a' of executeAction()

void addRoom(string name_input, int no_input, libraryType type) 
{
	Container* tempList = list;				// work on a copy of 'list'
	Container* previous = list;
	Container* container = new Container();
	Room* newPlace;

	//check if the list is empty
	if (tempList == NULL) {

		//adds new room type hayden to the list
		if (type == hayden) {
			//creates a pointer to a room object
			newPlace = new Hayden(name_input, no_input, type);
			//adds room to container object
			container->room = newPlace;
			//sets the templist first element to be this new object we created
			list = container;
			//sets the next to be null
			list->next = NULL;
		}
		//adds new room type noble to the list
		if (type == noble) {
			//creates a pointer to a room object
			newPlace = new Noble(name_input, no_input, type);
			//adds room to container object
			container->room = newPlace;
			//sets the templist first element to be this new object we created
			list = container;
			//sets the next to be null
			list->next = NULL;
		}
	}

	//else if this is a room that is being added to a non empty list do this
	else {
		if (type == hayden) {
			//creates a pointer to a room object
			newPlace = new Hayden(name_input, no_input, type);
			//adds room to container object
			container->room = newPlace;
		}
		//adds new room type noble to the list
		if (type == noble) {
			//creates a pointer to a room object
			newPlace = new Noble(name_input, no_input, type);
			//adds room to container object
			container->room = newPlace;
		}

		// this while loop will loop until the final node that has an element is found and insert
		while (tempList != NULL) {
			previous = tempList;
			tempList = tempList->next;
		}

		//set that last element to be this new object rather than null
		previous->next = container;
		container->next = NULL;

	}
}

// Q5: displayList	(4 points)
// This function displays the list of room and their details (name, no, library name)
// Parse the list and use the class member function to display the room info.
// See expected output in the question file.
// No implementation needed here, however it may be helpful to review this function

void displayList()
{
	Container *tempList = list;			// work on a copy of 'list'

	//goes through each node until the tempList is pointing to NULL
	while (tempList != NULL) {
		cout << "\n";
		//print the display method
		tempList->room->displayRoom();
		tempList = tempList->next;
	}
}

// Q6: save  (7 points)
// Save the linked list of rooms to a file list.txt using ofstream.
// You will need to save the number of rooms in linked list. That will help in load() when reading the file.
// One format to store is:
// <no. of rooms>
// <Room1 name>
// <Room1 no>
// <Room type>
// <Room2 name>
// <Room2 no>
// <Room2 type>
// and so on..
// You may store the list in another format if you wish. You need to read the file in load () the same way that it is saved in save().
// This function is called when exiting the program (end of main() ).
// Hint: You may want to cast the enum ‘libraryType’ to an int before writing it to the file.


void save(string fileName)
{
	//keeps track of the number of rooms
	int numberOfRooms = 0;
	//iterater variable that is currently pointing to the head of the list
	Container* iterator = list;
	//declaring a file type variable
	ofstream file;

	//count the number of nodes in this link list
	while (iterator != NULL)
	{
		iterator = iterator->next;
		numberOfRooms++;
	}

	//open the file with the name given
	file.open(fileName);

	if (file.is_open()) 
	{
		iterator = list;
		//save the number of rooms to the file first
		file << numberOfRooms << endl;

		while (iterator != NULL)
		{
			//writes the name, number and type to file in new lines
			file << iterator->room->getName() << endl;
			file << iterator->room->getNo() << endl;
			file << iterator->room->getLibraryType() << endl;

			//once that room has been written  move on
			iterator = iterator->next;
		}
		file.close();
	}
	
}

// Q7: load (7 points)
// Load the linked list of rooms from the file using ifstream.
// You will need to create the linked list in the same order that is was saved to the file in save().
// First, read the number of rooms saved in the file.
// Then, for every room you will need to create a new Room node depending on room type. You may add the room to head or tail of the list. 
// Hint: If you casted the enum 'libraryType' to an int, you will need to cast it back to 'libraryType' when making the room node.
// This function is called at the beginning of main().

void load(string fileName)
{
	//keeps track of the number of rooms
	int numberOfRooms = 0;
	//iterater variable that is currently pointing to the head of the list
	Container* iterator = list;
	//declaring a file type variable
	ifstream file;
	string name;
	string roomNumber;
	string roomType;
	int roomTypeAsAnInt;
	int roomNumberAsInt;

	//open file
	file.open(fileName);
	if (file.is_open()) 
	{
		//read the number of rooms
		file >> numberOfRooms;
		//iterate theough this save file with nodes
		for (int i = 0; i < numberOfRooms; i++)
		{
			//create a new container variable
			Container* temp = new Container();
			file >> name;
			file >> roomNumber;
			file >> roomType;
			roomTypeAsAnInt = stoi(roomType);
			roomNumberAsInt = stoi(roomNumber);
			
			//create the new room objext by using the contructor
			if (roomTypeAsAnInt == 0) {
				temp->room = new Hayden(name, roomNumberAsInt, hayden);
			}
			if (roomTypeAsAnInt == 1) {
				temp->room = new Noble(name, roomNumberAsInt, noble);
			}

			//adds the first object to the head 
			if (i == 0) 
			{
				iterator = temp;
				temp->next = NULL;
			}
			//if the index is not zero then we want to add temp after the element we just added and set the next of it to be null
			else 
			{
				iterator->next = temp;
				temp->next = NULL;
			}
		}
		//close the file
		file.close();
	}
	
}
